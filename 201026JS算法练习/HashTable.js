//哈希表（Hash table，也叫散列表），
// 是根据关键码值(Key value)而直接进行访问的数据结构。
// 也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
// 这个映射函数叫做散列函数，存放记录的数组叫做散列表。
//哈希表可以存储各种类型的数据
//当我们从哈希表中查找所需要的数据时，理想情况是不经过任何比较，一次存取便能得到所查记录
//那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，
//使每个关键字和结构中一个唯一的存储位置相对应。(关键字就是所要存储的数据，存储位置相当于数组的索引)
//哈希冲突
//我们所要存储的数据其关键字是一个人的身份证号(18位数字)
//比如一个人的身份证号是 411697199702076425，我们很难直接让关键字与数字建立一一对应的关系，并且保证数字适合作为数组的索引。
//在这种情况下，通过哈希函数计算出的索引，即使关键字不同，索引也会有可能相同。这就是哈希冲突
//空间换时间
//哈希表充分体现了空间换时间这种经典的算法思想。
//关键字是大整数时，比如身份证号，411697199702076425
//假如我们能开辟一个 999999999999999999 大的空间，这样就能直接把身份证号作为关键字存储到数组中，这样可以用O(1)时间完成各项操作
//假如我们只有 1 的空间，我们需要把所有信息存储到这个空间中(也就是所有数据都会产生哈希冲突)，我们只能用O(n)时间完成各项操作
//事实上，我们不可能开辟一个如此大的空间，也不可会开辟如此小的空间
//无限空间时，时间为O(1)
//1的空间时，时间为O(n)
//而哈希表就是在二者之间产生一个平衡，即空间和时间的平衡。
//在哈希表中，记录的存储位置 = f (关键字)，通过查找关键字的存储位置即可，不用进行比较。
//散列技术是在记录的存储位置和它的关键字之间建立一个明确的对应关系f 函数，使得每个关键字 key 对应一个存储位置 f(key) 且这个位置是唯一的。
//这里我们将这种对应关系 f 称为散列函数，又称为哈希(Hash)函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。

//计数排序
let a = {
  0: 0,
  1: 2,
  2: 1,
  3: 56,
  4: 3,
  5: 67,
  6: 3,
  length: 7,
};
//object的key一定是字符串或数字，是数字的时候会自动转为字符串
let hash = {};
for (let index = 0; index < a["length"]; index++) {
  number = a[index]; //0,2,1,56,3,67,3
  if (hash[number] == undefined) {
    hash[number] = 1;
  } else {
    hash[number] = hash[number] + 1;
  }
}
console.log(hash);
//hash{
//  0:1,
//  1:1,
//  2:1,
//  3:2,
//  56:1,
//  67:1
//}
//哈希计数
//接下来遍历哈希
//找a这个数组里的最大值就是找hash的length
//hash[0]=1,表示有1个0
let max = 0;
for (let i = 0; i < a["length"]; i++) {
  if (a[i] > max) {
    max = a[i];
  }
}
//获得a的最大值max
let newArr = [];
for (let index = 1; index < max + 1; index++) {
  let count = hash[index];
  if (count !== undefined) {
    for (i = 1; i <= count; i++) {
      newArr.push(index);
    }
  }
}
console.log(newArr);
//复杂度 O(n+max)
